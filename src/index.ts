#!/usr/bin/env node

import { Command } from "commander";
import fs from "fs-extra";
import path from "node:path";
import { execa } from "execa";
import { confirm, select } from "@inquirer/prompts";

const program = new Command();

program
  .name("create-ai-stack")
  .description("AI Workspace Standardizer (Cursor/Claude adapters)")
  .version("0.3.1");

/* ======================================================
   CONSTANTS
====================================================== */

const GENERATED_HEADER = `# ‚ö†Ô∏è Generated by create-ai-stack
# Do not edit manually.
# Edit .ai/* and run: create-ai-stack sync
`;

/* ======================================================
   MAGIC (DEFAULT)
====================================================== */

program
  .command("magic", { isDefault: true })
  .description("Modo m√°gico: configura el repo autom√°ticamente")
  .option("--tool <tool>", "cursor | claude | both (no-interactivo)")
  .option("--force", "Sobrescribe adapters existentes", false)
  .action(async (opts: { tool?: "cursor" | "claude" | "both"; force: boolean }) => {
    const cwd = process.cwd();

    if (!opts.tool) {
      await runMagicInteractive(cwd);
      return;
    }

    await runMagicNonInteractive(cwd, opts.tool, opts.force);
  });

/* ======================================================
   INIT
====================================================== */

program
  .command("init")
  .description("Inicializa la estructura .ai/ (en este repo o en una carpeta nueva)")
  .argument("[project-name]", "Nombre de carpeta opcional")
  .action(async (projectName?: string) => {
    const cwd = projectName ? path.resolve(process.cwd(), projectName) : process.cwd();
    await fs.mkdirp(cwd);
    await createBaseAI(cwd);
    console.log("‚úÖ Estructura .ai/ creada o verificada");
  });

/* ======================================================
   ADD
====================================================== */

program
  .command("add")
  .description("Agrega/genera configuraci√≥n para una herramienta AI")
  .argument("<tool>", "cursor | claude")
  .option("--force", "Sobrescribe si ya existe", false)
  .action(async (tool: string, opts: { force: boolean }) => {
    const cwd = process.cwd();

    const aiPath = path.join(cwd, ".ai");
    if (!(await fs.pathExists(aiPath))) {
      console.log("‚ö†Ô∏è No existe .ai/, creando estructura base...");
      await createBaseAI(cwd);
    } else {
      await ensureAiMinimum(cwd);
    }

    if (tool === "cursor") {
      await generateCursorWithOverwritePrompt(cwd, opts.force);
      return;
    }

    if (tool === "claude") {
      await generateClaudeWithOverwritePrompt(cwd, opts.force);
      return;
    }

    console.error("‚ùå Tool no soportada. Usa: cursor | claude");
    process.exit(1);
  });

/* ======================================================
   SYNC
====================================================== */

program
  .command("sync")
  .description("Regenera adapters desde .ai/ (sin wizard)")
  .argument("[tool]", "cursor | claude | both", "cursor")
  .option("--force", "Sobrescribe adapters existentes aunque no sean de create-ai-stack", false)
  .action(async (tool: "cursor" | "claude" | "both", opts: { force: boolean }) => {
    const cwd = process.cwd();

    const aiPath = path.join(cwd, ".ai");
    if (!(await fs.pathExists(aiPath))) {
      console.log("‚ö†Ô∏è No existe .ai/, creando estructura base...");
      await createBaseAI(cwd);
    } else {
      await ensureAiMinimum(cwd);
    }

    console.log("üîÑ Sincronizando adapters...\n");

    const results: { label: string; ok: boolean; note?: string }[] = [];

    if (tool === "cursor" || tool === "both") {
      results.push(await generateCursorWithOverwritePrompt(cwd, opts.force, true));
    }

    if (tool === "claude" || tool === "both") {
      results.push(await generateClaudeWithOverwritePrompt(cwd, opts.force, true));
    }

    console.log("‚úÖ Sync completado.\n");
    for (const r of results) {
      console.log(`  ${r.ok ? "‚úÖ" : "‚ö†Ô∏è"} ${r.label}${r.note ? " ‚Äî " + r.note : ""}`);
    }

    console.log("\nüìå Estado:");
    printDoctorReport(await inspectRepo(cwd), await detectTools());
  });

/* ======================================================
   DOCTOR
====================================================== */

program
  .command("doctor")
  .description("Diagnostica el estado del repo y su setup de IA")
  .action(async () => {
    const cwd = process.cwd();
    const repo = await inspectRepo(cwd);
    const tools = await detectTools();
    printDoctorReport(repo, tools);
    process.exit(repo.hasAiDir ? 0 : 1);
  });

program.parse();

/* ======================================================
   MAGIC: INTERACTIVE FLOW
====================================================== */

async function runMagicInteractive(cwd: string) {
  const repo = await inspectRepo(cwd);

  if (!repo.hasAiDir && !repo.hasCursorRules && !repo.hasClaudeMd) {
    const wants = await confirm({
      message: "No tienes nada configurado. ¬øQuieres configurar un AI workspace ahora?",
      default: true,
    });

    if (!wants) {
      console.log("Listo. Cuando quieras, ejecuta: create-ai-stack init");
      return;
    }
  }

  const detected = await detectProjectSignals(cwd);
  const recommended = recommendTool(detected);

  const tool = await select<"cursor" | "claude" | "both">({
    message: "¬øQu√© quieres configurar?",
    choices: [
      {
        name: `Cursor (.cursorrules)${recommended === "cursor" ? " ‚Äî recomendado" : ""}`,
        value: "cursor",
      },
      {
        name: `Claude (CLAUDE.md)${recommended === "claude" ? " ‚Äî recomendado" : ""}`,
        value: "claude",
      },
      {
        name: `Ambos${recommended === "both" ? " ‚Äî recomendado" : ""}`,
        value: "both",
      },
    ],
  });

  console.log("\nüöÄ Iniciando configuraci√≥n...\n");

  const created = await ensureAiMinimumOrCreate(cwd);

  const results: { label: string; ok: boolean; note?: string }[] = [];

  if (tool === "cursor" || tool === "both") {
    results.push(await generateCursorWithOverwritePrompt(cwd, false));
  }

  if (tool === "claude" || tool === "both") {
    results.push(await generateClaudeWithOverwritePrompt(cwd, false));
  }

  console.log("‚úÖ Hecho. Checklist:\n");
  for (const r of results) {
    console.log(`  ${r.ok ? "‚úÖ" : "‚ö†Ô∏è"} ${r.label}${r.note ? " ‚Äî " + r.note : ""}`);
  }
  if (created.createdAiDir) console.log("  ‚úÖ Creada carpeta .ai/");
  if (created.bootstrappedContext) console.log("  ‚úÖ Generado/asegurado .ai/context.md");
  if (created.ensuredPlaybooks) console.log("  ‚úÖ Playbooks asegurados (.ai/playbooks/)");

  const finalRepo = await inspectRepo(cwd);
  console.log("\nüìå Estado final:");
  printDoctorReport(finalRepo, await detectTools());

  console.log("\nüëâ Siguiente paso recomendado:");
  console.log("  1) Abre .ai/context.md y escribe el prop√≥sito del proyecto en 2‚Äì4 l√≠neas");
  console.log("  2) Ajusta .ai/rules.md seg√∫n tu estilo");
  console.log("  3) Vuelve a correr: create-ai-stack sync cursor --force (para regenerar)");
}

/* ======================================================
   MAGIC: NON-INTERACTIVE
====================================================== */

async function runMagicNonInteractive(
  cwd: string,
  tool: "cursor" | "claude" | "both",
  force: boolean
) {
  const before = await inspectRepo(cwd);

  if (!before.hasAiDir) {
    console.log("‚ú® No existe .ai/ ‚Üí creando estructura base...");
    await createBaseAI(cwd);
  } else {
    await ensureAiMinimum(cwd);
  }

  const results: { label: string; ok: boolean; note?: string }[] = [];

  if (tool === "cursor" || tool === "both") {
    results.push(await generateCursorWithOverwritePrompt(cwd, force, true));
  }
  if (tool === "claude" || tool === "both") {
    results.push(await generateClaudeWithOverwritePrompt(cwd, force, true));
  }

  console.log("\n‚úÖ Modo m√°gico completado.\n");
  for (const r of results) {
    console.log(`  ${r.ok ? "‚úÖ" : "‚ö†Ô∏è"} ${r.label}${r.note ? " ‚Äî " + r.note : ""}`);
  }

  printDoctorReport(await inspectRepo(cwd), await detectTools());
}

/* ======================================================
   OVERWRITE PROMPTS
====================================================== */

async function generateCursorWithOverwritePrompt(
  projectPath: string,
  force: boolean,
  nonInteractive = false
): Promise<{ label: string; ok: boolean; note?: string }> {
  const outPath = path.join(projectPath, ".cursorrules");

  if (await fs.pathExists(outPath)) {
    const ours = await isGeneratedByUs(outPath);

    if (ours && !force) {
      await addCursorConfig(projectPath);
      return { label: "Regenerado .cursorrules (archivo era de create-ai-stack)", ok: true };
    }

    if (!force) {
      if (nonInteractive) {
        return {
          label: "No se sobrescribi√≥ .cursorrules",
          ok: true,
          note: "ya existe (usa --force para sobrescribir)",
        };
      }

      const overwrite = await confirm({
        message: "Ya existe .cursorrules. ¬øQuieres sobrescribirlo?",
        default: false,
      });

      if (!overwrite) {
        return { label: "No se sobrescribi√≥ .cursorrules", ok: true, note: "lo dej√© intacto" };
      }
    }
  }

  await addCursorConfig(projectPath);
  return { label: "Generado .cursorrules", ok: true };
}

async function generateClaudeWithOverwritePrompt(
  projectPath: string,
  force: boolean,
  nonInteractive = false
): Promise<{ label: string; ok: boolean; note?: string }> {
  const outPath = path.join(projectPath, "CLAUDE.md");

  if (await fs.pathExists(outPath)) {
    const ours = await isGeneratedByUs(outPath);

    if (ours && !force) {
      await addClaudeConfig(projectPath);
      return { label: "Regenerado CLAUDE.md (archivo era de create-ai-stack)", ok: true };
    }

    if (!force) {
      if (nonInteractive) {
        return {
          label: "No se sobrescribi√≥ CLAUDE.md",
          ok: true,
          note: "ya existe (usa --force para sobrescribir)",
        };
      }

      const overwrite = await confirm({
        message: "Ya existe CLAUDE.md. ¬øQuieres sobrescribirlo?",
        default: false,
      });

      if (!overwrite) {
        return { label: "No se sobrescribi√≥ CLAUDE.md", ok: true, note: "lo dej√© intacto" };
      }
    }
  }

  await addClaudeConfig(projectPath);
  return { label: "Generado CLAUDE.md", ok: true };
}

async function isGeneratedByUs(filePath: string) {
  if (!(await fs.pathExists(filePath))) return false;
  const head = (await fs.readFile(filePath, "utf8")).slice(0, 800);
  return head.includes("Generated by create-ai-stack") || head.includes("create-ai-stack");
}

/* ======================================================
   CORE: .ai/ BASE
====================================================== */

async function createBaseAI(projectPath: string) {
  const aiDir = path.join(projectPath, ".ai");
  const playbooksDir = path.join(aiDir, "playbooks");

  await fs.mkdirp(playbooksDir);

  const contextPath = path.join(aiDir, "context.md");
  if (!(await fs.pathExists(contextPath))) {
    const context = await bootstrapContext(projectPath);
    await fs.writeFile(contextPath, context, "utf8");
  }

  const rulesPath = path.join(aiDir, "rules.md");
  if (!(await fs.pathExists(rulesPath))) {
    await fs.writeFile(
      rulesPath,
      `# Coding Rules

- Usa nombres consistentes
- Prefiere cambios peque√±os y verificables
- No inventes APIs: si falta info, dilo y propone opciones
- Mant√©n el estilo del repo (TypeScript/ESLint/Prettier si existen)
`,
      "utf8"
    );
  }

  await ensurePlaybooks(projectPath);

  const aiReadme = path.join(aiDir, "README.md");
  if (!(await fs.pathExists(aiReadme))) {
    await fs.writeFile(
      aiReadme,
      `# AI Workspace

Fuente de verdad:
- context.md (qu√© es el proyecto + comandos + estructura)
- rules.md (reglas del repo)
- playbooks/ (workflows repetibles)

Adapters generados:
- .cursorrules (Cursor)
- CLAUDE.md (Claude)
`,
      "utf8"
    );
  }
}

async function ensureAiMinimum(projectPath: string) {
  const aiDir = path.join(projectPath, ".ai");
  if (!(await fs.pathExists(aiDir))) return;

  const contextPath = path.join(aiDir, "context.md");
  const rulesPath = path.join(aiDir, "rules.md");

  if (!(await fs.pathExists(contextPath))) {
    await fs.writeFile(contextPath, await bootstrapContext(projectPath), "utf8");
  }

  if (!(await fs.pathExists(rulesPath))) {
    await fs.writeFile(
      rulesPath,
      `# Coding Rules

- Define reglas aqu√≠
`,
      "utf8"
    );
  }

  await ensurePlaybooks(projectPath);
}

async function ensurePlaybooks(projectPath: string): Promise<boolean> {
  const aiDir = path.join(projectPath, ".ai");
  const playbooksDir = path.join(aiDir, "playbooks");
  await fs.mkdirp(playbooksDir);

  let wrote = false;

  const bugfix = path.join(playbooksDir, "bugfix.md");
  if (!(await fs.pathExists(bugfix))) {
    await fs.writeFile(
      bugfix,
      `# Bugfix Playbook

1. Reproduce el bug (pasos claros)
2. Encuentra causa ra√≠z (archivo/funci√≥n/condici√≥n)
3. Aplica fix m√≠nimo
4. Agrega/actualiza test si aplica
`,
      "utf8"
    );
    wrote = true;
  }

  const refactor = path.join(playbooksDir, "refactor.md");
  if (!(await fs.pathExists(refactor))) {
    await fs.writeFile(
      refactor,
      `# Refactor Playbook

1. Define objetivo (legibilidad/perf/mantenibilidad)
2. Cambios peque√±os por commit
3. Mant√©n comportamiento igual (tests/validaciones)
4. Limpia deuda (nombres, tipos, duplicaci√≥n)
`,
      "utf8"
    );
    wrote = true;
  }

  const feature = path.join(playbooksDir, "new-feature.md");
  if (!(await fs.pathExists(feature))) {
    await fs.writeFile(
      feature,
      `# New Feature Playbook

1. Entender requerimiento y alcance
2. Dise√±ar cambios m√≠nimos (archivos tocados)
3. Implementar
4. Verificar (lint/test/build)
5. Documentar si aplica
`,
      "utf8"
    );
    wrote = true;
  }

  return wrote;
}

async function ensureAiMinimumOrCreate(projectPath: string): Promise<{
  createdAiDir: boolean;
  bootstrappedContext: boolean;
  ensuredPlaybooks: boolean;
}> {
  const aiDir = path.join(projectPath, ".ai");
  const hadAi = await fs.pathExists(aiDir);

  let ensuredPlaybooks = false;

  if (!hadAi) {
    await createBaseAI(projectPath);
    ensuredPlaybooks = true;
  } else {
    await ensureAiMinimum(projectPath);
    ensuredPlaybooks = true;
  }

  const contextPath = path.join(aiDir, "context.md");
  const bootstrappedContext = await fs.pathExists(contextPath);

  return {
    createdAiDir: !hadAi,
    bootstrappedContext,
    ensuredPlaybooks,
  };
}

/* ======================================================
   ADAPTERS
====================================================== */

async function detectRepoCommands(projectPath: string): Promise<{
  install?: string;
  dev?: string;
  test?: string;
  lint?: string;
  build?: string;
}> {
  const pkgPath = path.join(projectPath, "package.json");
  if (!(await fs.pathExists(pkgPath))) return {};

  try {
    const pkg = await fs.readJson(pkgPath);
    const scripts = pkg.scripts || {};
    const has = (k: string) => Boolean(scripts[k]);

    return {
      install: "npm i",
      dev: has("dev") ? "npm run dev" : undefined,
      test: has("test") ? "npm test" : undefined,
      lint: has("lint") ? "npm run lint" : undefined,
      build: has("build") ? "npm run build" : undefined,
    };
  } catch {
    return {};
  }
}

async function addCursorConfig(projectPath: string) {
  const context = await fs.readFile(path.join(projectPath, ".ai", "context.md"), "utf8");
  const rules = await fs.readFile(path.join(projectPath, ".ai", "rules.md"), "utf8");
  const cmds = await detectRepoCommands(projectPath);

  const playbooksDir = path.join(projectPath, ".ai", "playbooks");
  const playbooks = (await fs.pathExists(playbooksDir))
    ? (await fs.readdir(playbooksDir)).filter((f) => f.endsWith(".md"))
    : [];

  const playbooksIndex = playbooks.length
    ? playbooks.map((p) => `- ${p.replace(/\.md$/, "")}: ver .ai/playbooks/${p}`).join("\n")
    : "- (sin playbooks a√∫n)";

  const commandsBlock = [
    "## Repo Commands",
    cmds.install ? `- Install: ${cmds.install}` : null,
    cmds.dev ? `- Dev: ${cmds.dev}` : null,
    cmds.test ? `- Test: ${cmds.test}` : null,
    cmds.lint ? `- Lint: ${cmds.lint}` : null,
    cmds.build ? `- Build: ${cmds.build}` : null,
  ]
    .filter(Boolean)
    .join("\n");

  const content = `${GENERATED_HEADER}
# Cursor Rules

## Project Context
${context.trim()}

## Coding Rules
${rules.trim()}

${commandsBlock}

## Playbooks
${playbooksIndex}

## Quality Gate
- Antes de finalizar cambios: corre lint/test/build si existen.
- Mant√©n cambios peque√±os y verificables.
- Si falta informaci√≥n: pide el archivo exacto o declara suposiciones m√≠nimas.
`;

  await fs.writeFile(path.join(projectPath, ".cursorrules"), content, "utf8");
}

async function addClaudeConfig(projectPath: string) {
  const contextPath = path.join(projectPath, ".ai", "context.md");
  const rulesPath = path.join(projectPath, ".ai", "rules.md");

  const context = (await fs.pathExists(contextPath))
    ? await fs.readFile(contextPath, "utf8")
    : "";
  const rules = (await fs.pathExists(rulesPath)) ? await fs.readFile(rulesPath, "utf8") : "";

  const content = `${GENERATED_HEADER}
# Claude Instructions

## Project Context
${context.trim()}

## Rules
${rules.trim()}

## Quality Gate
- Mant√©n cambios m√≠nimos.
- No inventes APIs ni archivos.
- Antes de finalizar: sugiere c√≥mo validar (tests/lint/build).
`;

  await fs.writeFile(path.join(projectPath, "CLAUDE.md"), content, "utf8");
}

/* ======================================================
   PROJECT SIGNALS + RECOMMENDATION
====================================================== */

type ProjectSignals = {
  isJsRepo: boolean;
  hasTs: boolean;
  hasReact: boolean;
  hasNext: boolean;
  hasVite: boolean;
  hasBackend: boolean;
};

async function detectProjectSignals(projectPath: string): Promise<ProjectSignals> {
  const pkgPath = path.join(projectPath, "package.json");

  let deps: Record<string, any> = {};
  if (await fs.pathExists(pkgPath)) {
    try {
      const pkg = await fs.readJson(pkgPath);
      deps = { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) };
    } catch {
      deps = {};
    }
  }

  const hasTs = Boolean(deps.typescript);
  const hasReact = Boolean(deps.react);
  const hasNext = Boolean(deps.next);
  const hasVite = Boolean(deps.vite);
  const hasBackend = Boolean(deps["@nestjs/core"] || deps.express || deps.fastify);

  return {
    isJsRepo: await fs.pathExists(pkgPath),
    hasTs,
    hasReact,
    hasNext,
    hasVite,
    hasBackend,
  };
}

function recommendTool(signals: ProjectSignals): "cursor" | "claude" | "both" {
  if (signals.hasReact || signals.hasNext || signals.hasVite || signals.hasTs) {
    if (signals.hasBackend) return "both";
    return "cursor";
  }
  if (signals.hasBackend) return "claude";
  return "cursor";
}

/* ======================================================
   BOOTSTRAP CONTEXT
====================================================== */

async function bootstrapContext(projectPath: string): Promise<string> {
  const stack: string[] = [];
  const scripts: string[] = [];
  const hints: string[] = [];

  const pkgPath = path.join(projectPath, "package.json");
  if (await fs.pathExists(pkgPath)) {
    try {
      const pkg = await fs.readJson(pkgPath);
      const deps = { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) };

      if (deps.typescript) stack.push("TypeScript");
      if (deps.react) stack.push("React");
      if (deps.next) stack.push("Next.js");
      if (deps.vite) stack.push("Vite");
      if (deps["@nestjs/core"]) stack.push("NestJS");
      if (deps.tailwindcss) stack.push("Tailwind CSS");
      if (deps.firebase) stack.push("Firebase");

      if (pkg.scripts) scripts.push(...Object.keys(pkg.scripts));

      if (deps.eslint) hints.push("ESLint detectado");
      if (deps.prettier) hints.push("Prettier detectado");
      if (deps.jest || deps.vitest) hints.push("Testing detectado (Jest/Vitest)");
    } catch {
      // ignore
    }
  }

  const commonDirs = ["src", "apps", "packages", "server", "client"];
  const existingDirs: string[] = [];
  for (const d of commonDirs) {
    if (await fs.pathExists(path.join(projectPath, d))) existingDirs.push(d);
  }

  let readmeHint = "";
  const readmePath = path.join(projectPath, "README.md");
  if (await fs.pathExists(readmePath)) {
    const txt = await fs.readFile(readmePath, "utf8");
    const firstLines = txt
      .split("\n")
      .slice(0, 12)
      .map((l) => l.trim())
      .filter(Boolean)
      .slice(0, 6);
    if (firstLines.length) {
      readmeHint = firstLines.map((l) => `> ${l}`).join("\n");
    }
  }

  return `# Project Context

## Qu√© es este proyecto
(Describe en 2-4 l√≠neas el objetivo del repo.)

${readmeHint ? `## Extracto de README (referencia)\n${readmeHint}\n` : ""}

## Stack detectado
${stack.length ? stack.map((s) => `- ${s}`).join("\n") : "- No detectado (completa esto)"}

## Scripts disponibles
${scripts.length ? scripts.map((s) => `- ${s}`).join("\n") : "- No hay scripts (o no hay package.json)"}

## Estructura (carpetas comunes encontradas)
${existingDirs.length ? existingDirs.map((d) => `- ${d}/`).join("\n") : "- No detectada"}

## Pistas
${hints.length ? hints.map((h) => `- ${h}`).join("\n") : "- (sin pistas)"}

## Comandos de trabajo (completa)
- Instalar dependencias:
- Correr dev:
- Correr tests:
- Lint/format:
- Build:
`;
}

/* ======================================================
   DOCTOR HELPERS
====================================================== */

type RepoInspection = {
  hasAiDir: boolean;
  hasContext: boolean;
  hasRules: boolean;
  hasPlaybooksDir: boolean;
  playbooksCount: number;
  hasCursorRules: boolean;
  hasClaudeMd: boolean;
};

async function inspectRepo(projectPath: string): Promise<RepoInspection> {
  const aiDir = path.join(projectPath, ".ai");
  const playbooksDir = path.join(aiDir, "playbooks");

  const hasAiDir = await fs.pathExists(aiDir);
  const hasContext = await fs.pathExists(path.join(aiDir, "context.md"));
  const hasRules = await fs.pathExists(path.join(aiDir, "rules.md"));
  const hasPlaybooksDir = await fs.pathExists(playbooksDir);

  let playbooksCount = 0;
  if (hasPlaybooksDir) {
    const files = await fs.readdir(playbooksDir);
    playbooksCount = files.filter((f) => f.endsWith(".md")).length;
  }

  const hasCursorRules = await fs.pathExists(path.join(projectPath, ".cursorrules"));
  const hasClaudeMd = await fs.pathExists(path.join(projectPath, "CLAUDE.md"));

  return {
    hasAiDir,
    hasContext,
    hasRules,
    hasPlaybooksDir,
    playbooksCount,
    hasCursorRules,
    hasClaudeMd,
  };
}

type ToolDetection = Record<string, boolean>;

async function detectTools(): Promise<ToolDetection> {
  const candidates: Record<string, string[]> = {
    cursorCli: ["cursor", "cursor-agent"],
    claudeCli: ["claude", "claude-code"],
    vscode: ["code"],
    aider: ["aider"],
    opencode: ["opencode"],
    copilot: ["copilot"],
  };

  const result: ToolDetection = {};
  for (const [tool, cmds] of Object.entries(candidates)) {
    let found = false;
    for (const cmd of cmds) {
      if (await commandExists(cmd)) {
        found = true;
        break;
      }
    }
    result[tool] = found;
  }
  return result;
}

async function commandExists(cmd: string): Promise<boolean> {
  try {
    const checker = process.platform === "win32" ? "where" : "which";
    await execa(checker, [cmd]);
    return true;
  } catch {
    return false;
  }
}

function printDoctorReport(repo: RepoInspection, tools: ToolDetection) {
  console.log("\nüìÅ Repo setup:");
  console.log(`  .ai/ existe: ${repo.hasAiDir ? "‚úÖ" : "‚ùå"}`);
  console.log(`  context.md: ${repo.hasContext ? "‚úÖ" : "‚ùå"}`);
  console.log(`  rules.md: ${repo.hasRules ? "‚úÖ" : "‚ùå"}`);
  console.log(
    `  playbooks/: ${repo.hasPlaybooksDir ? "‚úÖ" : "‚ùå"} (${repo.playbooksCount} .md)`
  );

  console.log("\nüß© Adaptadores:");
  console.log(`  .cursorrules: ${repo.hasCursorRules ? "‚úÖ" : "‚ùå"}`);
  console.log(`  CLAUDE.md: ${repo.hasClaudeMd ? "‚úÖ" : "‚ùå"}`);

  console.log("\nüîé Tools en PATH (opcional):");
  for (const [k, v] of Object.entries(tools)) {
    console.log(`  ${k}: ${v ? "‚úÖ" : "‚ùå"}`);
  }
}