#!/usr/bin/env node

import { Command } from "commander";
import fs from "fs-extra";
import path from "node:path";
import { execa } from "execa";
import { confirm, select } from "@inquirer/prompts";

const program = new Command();

program
  .name("devstackai")
  .description("AI Workspace Standardizer (Cursor/Claude adapters)")
  .version("0.3.1");

/* ======================================================
   CONSTANTS
====================================================== */

const GENERATED_HEADER = `# ‚ö†Ô∏è Generated by devstackai
# Do not edit manually.
# Edit .ai/* and run: devstackai sync
`;

/* ======================================================
   MAGIC (DEFAULT)
====================================================== */

program
  .command("magic", { isDefault: true })
  .description("Magic mode: automatically configures the repo")
  .option("--tool <tool>", "cursor | claude | both (non-interactive)")
  .option("--force", "Overwrites existing adapters", false)
  .action(async (opts: { tool?: "cursor" | "claude" | "both"; force: boolean }) => {
    const cwd = process.cwd();

    if (!opts.tool) {
      await runMagicInteractive(cwd);
      return;
    }

    await runMagicNonInteractive(cwd, opts.tool, opts.force);
  });

/* ======================================================
   INIT
====================================================== */

program
  .command("init")
  .description("Initializes the .ai/ structure (in this repo or a new folder)")
  .argument("[project-name]", "Optional folder name")
  .action(async (projectName?: string) => {
    const cwd = projectName ? path.resolve(process.cwd(), projectName) : process.cwd();
    await fs.mkdirp(cwd);
    await createBaseAI(cwd);
    console.log("‚úÖ .ai/ structure created or verified");
  });

/* ======================================================
   ADD
====================================================== */

program
  .command("add")
  .description("Adds/generates configuration for an AI tool")
  .argument("<tool>", "cursor | claude")
  .option("--force", "Overwrites if it already exists", false)
  .action(async (tool: string, opts: { force: boolean }) => {
    const cwd = process.cwd();

    const aiPath = path.join(cwd, ".ai");
    if (!(await fs.pathExists(aiPath))) {
      console.log("‚ö†Ô∏è .ai/ does not exist, creating base structure...");
      await createBaseAI(cwd);
    } else {
      await ensureAiMinimum(cwd);
    }

    if (tool === "cursor") {
      await generateCursorWithOverwritePrompt(cwd, opts.force);
      return;
    }

    if (tool === "claude") {
      await generateClaudeWithOverwritePrompt(cwd, opts.force);
      return;
    }

    console.error("‚ùå Unsupported tool. Use: cursor | claude");
    process.exit(1);
  });

/* ======================================================
   SYNC
====================================================== */

program
  .command("sync")
  .description("Regenerates adapters from .ai/ (no wizard)")
  .argument("[tool]", "cursor | claude | both", "cursor")
  .option("--force", "Overwrites existing adapters even if not from devstackai", false)
  .action(async (tool: "cursor" | "claude" | "both", opts: { force: boolean }) => {
    const cwd = process.cwd();

    const aiPath = path.join(cwd, ".ai");
    if (!(await fs.pathExists(aiPath))) {
      console.log("‚ö†Ô∏è .ai/ does not exist, creating base structure...");
      await createBaseAI(cwd);
    } else {
      await ensureAiMinimum(cwd);
    }

    console.log("üîÑ Syncing adapters...\n");

    const results: { label: string; ok: boolean; note?: string }[] = [];

    if (tool === "cursor" || tool === "both") {
      results.push(await generateCursorWithOverwritePrompt(cwd, opts.force, true));
    }

    if (tool === "claude" || tool === "both") {
      results.push(await generateClaudeWithOverwritePrompt(cwd, opts.force, true));
    }

    console.log("‚úÖ Sync completed.\n");
    for (const r of results) {
      console.log(`  ${r.ok ? "‚úÖ" : "‚ö†Ô∏è"} ${r.label}${r.note ? " ‚Äî " + r.note : ""}`);
    }

    console.log("\nüìå Status:");
    printDoctorReport(await inspectRepo(cwd), await detectTools());
  });

/* ======================================================
   DOCTOR
====================================================== */

program
  .command("doctor")
  .description("Diagnoses repo status and AI setup")
  .action(async () => {
    const cwd = process.cwd();
    const repo = await inspectRepo(cwd);
    const tools = await detectTools();
    printDoctorReport(repo, tools);
    process.exit(repo.hasAiDir ? 0 : 1);
  });

program.parse();

/* ======================================================
   MAGIC: INTERACTIVE FLOW
====================================================== */

async function runMagicInteractive(cwd: string) {
  const repo = await inspectRepo(cwd);

  if (!repo.hasAiDir && !repo.hasCursorRules && !repo.hasClaudeMd) {
    const wants = await confirm({
      message: "You have nothing configured. Do you want to configure an AI workspace now?",
      default: true,
    });

    if (!wants) {
      console.log("Done. Whenever you want, run: devstackai init");
      return;
    }
  }

  const detected = await detectProjectSignals(cwd);
  const recommended = recommendTool(detected);

  const tool = await select<"cursor" | "claude" | "both">({
    message: "What do you want to configure?",
    choices: [
      {
        name: `Cursor (.cursorrules)${recommended === "cursor" ? " ‚Äî recommended" : ""}`,
        value: "cursor",
      },
      {
        name: `Claude (CLAUDE.md)${recommended === "claude" ? " ‚Äî recommended" : ""}`,
        value: "claude",
      },
      {
        name: `Both${recommended === "both" ? " ‚Äî recommended" : ""}`,
        value: "both",
      },
    ],
  });

  console.log("\nüöÄ Starting configuration...\n");

  const created = await ensureAiMinimumOrCreate(cwd);

  const results: { label: string; ok: boolean; note?: string }[] = [];

  if (tool === "cursor" || tool === "both") {
    results.push(await generateCursorWithOverwritePrompt(cwd, false));
  }

  if (tool === "claude" || tool === "both") {
    results.push(await generateClaudeWithOverwritePrompt(cwd, false));
  }

  console.log("‚úÖ Done. Checklist:\n");
  for (const r of results) {
    console.log(`  ${r.ok ? "‚úÖ" : "‚ö†Ô∏è"} ${r.label}${r.note ? " ‚Äî " + r.note : ""}`);
  }
  if (created.createdAiDir) console.log("  ‚úÖ Created .ai/ folder");
  if (created.bootstrappedContext) console.log("  ‚úÖ Generated/ensured .ai/context.md");
  if (created.ensuredPlaybooks) console.log("  ‚úÖ Playbooks ensured (.ai/playbooks/)");

  const finalRepo = await inspectRepo(cwd);
  console.log("\nüìå Final status:");
  printDoctorReport(finalRepo, await detectTools());

  console.log("\nüëâ Recommended next step:");
  console.log("  1) Open .ai/context.md and write the project purpose in 2‚Äì4 lines");
  console.log("  2) Adjust .ai/rules.md to your style");
  console.log("  3) Rerun: devstackai sync cursor --force (to regenerate)");
}

/* ======================================================
   MAGIC: NON-INTERACTIVE
====================================================== */

async function runMagicNonInteractive(
  cwd: string,
  tool: "cursor" | "claude" | "both",
  force: boolean
) {
  const before = await inspectRepo(cwd);

  if (!before.hasAiDir) {
    console.log("‚ú® .ai/ does not exist ‚Üí creating base structure...");
    await createBaseAI(cwd);
  } else {
    await ensureAiMinimum(cwd);
  }

  const results: { label: string; ok: boolean; note?: string }[] = [];

  if (tool === "cursor" || tool === "both") {
    results.push(await generateCursorWithOverwritePrompt(cwd, force, true));
  }
  if (tool === "claude" || tool === "both") {
    results.push(await generateClaudeWithOverwritePrompt(cwd, force, true));
  }

  console.log("\n‚úÖ Magic mode completed.\n");
  for (const r of results) {
    console.log(`  ${r.ok ? "‚úÖ" : "‚ö†Ô∏è"} ${r.label}${r.note ? " ‚Äî " + r.note : ""}`);
  }

  printDoctorReport(await inspectRepo(cwd), await detectTools());
}

/* ======================================================
   OVERWRITE PROMPTS
====================================================== */

async function generateCursorWithOverwritePrompt(
  projectPath: string,
  force: boolean,
  nonInteractive = false
): Promise<{ label: string; ok: boolean; note?: string }> {
  const outPath = path.join(projectPath, ".cursorrules");

  if (await fs.pathExists(outPath)) {
    const ours = await isGeneratedByUs(outPath);

    if (ours && !force) {
      await addCursorConfig(projectPath);
      return { label: "Regenerated .cursorrules (file was from devstackai)", ok: true };
    }

    if (!force) {
      if (nonInteractive) {
        return {
          label: "Did not overwrite .cursorrules",
          ok: true,
          note: "already exists (use --force to overwrite)",
        };
      }

      const overwrite = await confirm({
        message: ".cursorrules already exists. Overwrite?",
        default: false,
      });

      if (!overwrite) {
        return { label: "Did not overwrite .cursorrules", ok: true, note: "left intact" };
      }
    }
  }

  await addCursorConfig(projectPath);
  return { label: "Generated .cursorrules", ok: true };
}

async function generateClaudeWithOverwritePrompt(
  projectPath: string,
  force: boolean,
  nonInteractive = false
): Promise<{ label: string; ok: boolean; note?: string }> {
  const outPath = path.join(projectPath, "CLAUDE.md");

  if (await fs.pathExists(outPath)) {
    const ours = await isGeneratedByUs(outPath);

    if (ours && !force) {
      await addClaudeConfig(projectPath);
      return { label: "Regenerated CLAUDE.md (file was from devstackai)", ok: true };
    }

    if (!force) {
      if (nonInteractive) {
        return {
          label: "Did not overwrite CLAUDE.md",
          ok: true,
          note: "already exists (use --force to overwrite)",
        };
      }

      const overwrite = await confirm({
        message: "CLAUDE.md already exists. Overwrite?",
        default: false,
      });

      if (!overwrite) {
        return { label: "Did not overwrite CLAUDE.md", ok: true, note: "left intact" };
      }
    }
  }

  await addClaudeConfig(projectPath);
  return { label: "Generated CLAUDE.md", ok: true };
}

async function isGeneratedByUs(filePath: string) {
  if (!(await fs.pathExists(filePath))) return false;
  const head = (await fs.readFile(filePath, "utf8")).slice(0, 800);
  return head.includes("Generated by devstackai") || head.includes("devstackai");
}

/* ======================================================
   CORE: .ai/ BASE
====================================================== */

async function createBaseAI(projectPath: string) {
  const aiDir = path.join(projectPath, ".ai");
  const playbooksDir = path.join(aiDir, "playbooks");

  await fs.mkdirp(playbooksDir);

  const contextPath = path.join(aiDir, "context.md");
  if (!(await fs.pathExists(contextPath))) {
    const context = await bootstrapContext(projectPath);
    await fs.writeFile(contextPath, context, "utf8");
  }

  const rulesPath = path.join(aiDir, "rules.md");
  if (!(await fs.pathExists(rulesPath))) {
    await fs.writeFile(
      rulesPath,
      `# Coding Rules

- Use consistent naming
- Prefer small and verifiable changes
- Do not invent APIs: if info is missing, say so and propose options
- Keep the repo style (TypeScript/ESLint/Prettier if they exist)
`,
      "utf8"
    );
  }

  await ensurePlaybooks(projectPath);

  const aiReadme = path.join(aiDir, "README.md");
  if (!(await fs.pathExists(aiReadme))) {
    await fs.writeFile(
      aiReadme,
      `# AI Workspace

Source of truth:
- context.md (what is the project + commands + structure)
- rules.md (repo rules)
- playbooks/ (repeatable workflows)

Generated adapters:
- .cursorrules (Cursor)
- CLAUDE.md (Claude)
`,
      "utf8"
    );
  }
}

async function ensureAiMinimum(projectPath: string) {
  const aiDir = path.join(projectPath, ".ai");
  if (!(await fs.pathExists(aiDir))) return;

  const contextPath = path.join(aiDir, "context.md");
  const rulesPath = path.join(aiDir, "rules.md");

  if (!(await fs.pathExists(contextPath))) {
    await fs.writeFile(contextPath, await bootstrapContext(projectPath), "utf8");
  }

  if (!(await fs.pathExists(rulesPath))) {
    await fs.writeFile(
      rulesPath,
      `# Coding Rules

- Define rules here
`,
      "utf8"
    );
  }

  await ensurePlaybooks(projectPath);
}

async function ensurePlaybooks(projectPath: string): Promise<boolean> {
  const aiDir = path.join(projectPath, ".ai");
  const playbooksDir = path.join(aiDir, "playbooks");
  await fs.mkdirp(playbooksDir);

  let wrote = false;

  const bugfix = path.join(playbooksDir, "bugfix.md");
  if (!(await fs.pathExists(bugfix))) {
    await fs.writeFile(
      bugfix,
      `# Bugfix Playbook

1. Reproduce the bug (clear steps)
2. Find root cause (file/function/condition)
3. Apply minimal fix
4. Add/update test if applicable
`,
      "utf8"
    );
    wrote = true;
  }

  const refactor = path.join(playbooksDir, "refactor.md");
  if (!(await fs.pathExists(refactor))) {
    await fs.writeFile(
      refactor,
      `# Refactor Playbook

1. Define goal (readability/perf/maintainability)
2. Small changes per commit
3. Keep behavior equal (tests/validations)
4. Clean debt (naming, types, duplication)
`,
      "utf8"
    );
    wrote = true;
  }

  const feature = path.join(playbooksDir, "new-feature.md");
  if (!(await fs.pathExists(feature))) {
    await fs.writeFile(
      feature,
      `# New Feature Playbook

1. Understand requirement and scope
2. Design minimal changes (touched files)
3. Implement
4. Verify (lint/test/build)
5. Document if applicable
`,
      "utf8"
    );
    wrote = true;
  }

  return wrote;
}

async function ensureAiMinimumOrCreate(projectPath: string): Promise<{
  createdAiDir: boolean;
  bootstrappedContext: boolean;
  ensuredPlaybooks: boolean;
}> {
  const aiDir = path.join(projectPath, ".ai");
  const hadAi = await fs.pathExists(aiDir);

  let ensuredPlaybooks = false;

  if (!hadAi) {
    await createBaseAI(projectPath);
    ensuredPlaybooks = true;
  } else {
    await ensureAiMinimum(projectPath);
    ensuredPlaybooks = true;
  }

  const contextPath = path.join(aiDir, "context.md");
  const bootstrappedContext = await fs.pathExists(contextPath);

  return {
    createdAiDir: !hadAi,
    bootstrappedContext,
    ensuredPlaybooks,
  };
}

/* ======================================================
   ADAPTERS
====================================================== */

async function detectRepoCommands(projectPath: string): Promise<{
  install?: string;
  dev?: string;
  test?: string;
  lint?: string;
  build?: string;
}> {
  const pkgPath = path.join(projectPath, "package.json");
  if (!(await fs.pathExists(pkgPath))) return {};

  try {
    const pkg = await fs.readJson(pkgPath);
    const scripts = pkg.scripts || {};
    const has = (k: string) => Boolean(scripts[k]);

    return {
      install: "npm i",
      dev: has("dev") ? "npm run dev" : undefined,
      test: has("test") ? "npm test" : undefined,
      lint: has("lint") ? "npm run lint" : undefined,
      build: has("build") ? "npm run build" : undefined,
    };
  } catch {
    return {};
  }
}

async function addCursorConfig(projectPath: string) {
  const context = await fs.readFile(path.join(projectPath, ".ai", "context.md"), "utf8");
  const rules = await fs.readFile(path.join(projectPath, ".ai", "rules.md"), "utf8");
  const cmds = await detectRepoCommands(projectPath);

  const playbooksDir = path.join(projectPath, ".ai", "playbooks");
  const playbooks = (await fs.pathExists(playbooksDir))
    ? (await fs.readdir(playbooksDir)).filter((f) => f.endsWith(".md"))
    : [];

  const playbooksIndex = playbooks.length
    ? playbooks.map((p) => `- ${p.replace(/\.md$/, "")}: see .ai/playbooks/${p}`).join("\n")
    : "- (no playbooks yet)";

  const commandsBlock = [
    "## Repo Commands",
    cmds.install ? `- Install: ${cmds.install}` : null,
    cmds.dev ? `- Dev: ${cmds.dev}` : null,
    cmds.test ? `- Test: ${cmds.test}` : null,
    cmds.lint ? `- Lint: ${cmds.lint}` : null,
    cmds.build ? `- Build: ${cmds.build}` : null,
  ]
    .filter(Boolean)
    .join("\n");

  const content = `${GENERATED_HEADER}
# Cursor Rules

## Project Context
${context.trim()}

## Coding Rules
${rules.trim()}

${commandsBlock}

## Playbooks
${playbooksIndex}

## Quality Gate
- Before finalizing changes: run lint/test/build if they exist.
- Keep changes small and verifiable.
- If info is missing: ask for the exact file or declare minimal assumptions.
`;

  await fs.writeFile(path.join(projectPath, ".cursorrules"), content, "utf8");
}

async function addClaudeConfig(projectPath: string) {
  const contextPath = path.join(projectPath, ".ai", "context.md");
  const rulesPath = path.join(projectPath, ".ai", "rules.md");

  const context = (await fs.pathExists(contextPath))
    ? await fs.readFile(contextPath, "utf8")
    : "";
  const rules = (await fs.pathExists(rulesPath)) ? await fs.readFile(rulesPath, "utf8") : "";

  const content = `${GENERATED_HEADER}
# Claude Instructions

## Project Context
${context.trim()}

## Rules
${rules.trim()}

## Quality Gate
- Keep changes minimal.
- Do not invent APIs or files.
- Before finalizing: suggest how to validate (tests/lint/build).
`;

  await fs.writeFile(path.join(projectPath, "CLAUDE.md"), content, "utf8");
}

/* ======================================================
   PROJECT SIGNALS + RECOMMENDATION
====================================================== */

type ProjectSignals = {
  isJsRepo: boolean;
  hasTs: boolean;
  hasReact: boolean;
  hasNext: boolean;
  hasVite: boolean;
  hasBackend: boolean;
};

async function detectProjectSignals(projectPath: string): Promise<ProjectSignals> {
  const pkgPath = path.join(projectPath, "package.json");

  let deps: Record<string, any> = {};
  if (await fs.pathExists(pkgPath)) {
    try {
      const pkg = await fs.readJson(pkgPath);
      deps = { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) };
    } catch {
      deps = {};
    }
  }

  const hasTs = Boolean(deps.typescript);
  const hasReact = Boolean(deps.react);
  const hasNext = Boolean(deps.next);
  const hasVite = Boolean(deps.vite);
  const hasBackend = Boolean(deps["@nestjs/core"] || deps.express || deps.fastify);

  return {
    isJsRepo: await fs.pathExists(pkgPath),
    hasTs,
    hasReact,
    hasNext,
    hasVite,
    hasBackend,
  };
}

function recommendTool(signals: ProjectSignals): "cursor" | "claude" | "both" {
  if (signals.hasReact || signals.hasNext || signals.hasVite || signals.hasTs) {
    if (signals.hasBackend) return "both";
    return "cursor";
  }
  if (signals.hasBackend) return "claude";
  return "cursor";
}

/* ======================================================
   BOOTSTRAP CONTEXT
====================================================== */

async function bootstrapContext(projectPath: string): Promise<string> {
  const stack: string[] = [];
  const scripts: string[] = [];
  const hints: string[] = [];

  const pkgPath = path.join(projectPath, "package.json");
  if (await fs.pathExists(pkgPath)) {
    try {
      const pkg = await fs.readJson(pkgPath);
      const deps = { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) };

      if (deps.typescript) stack.push("TypeScript");
      if (deps.react) stack.push("React");
      if (deps.next) stack.push("Next.js");
      if (deps.vite) stack.push("Vite");
      if (deps["@nestjs/core"]) stack.push("NestJS");
      if (deps.tailwindcss) stack.push("Tailwind CSS");
      if (deps.firebase) stack.push("Firebase");

      if (pkg.scripts) scripts.push(...Object.keys(pkg.scripts));

      if (deps.eslint) hints.push("ESLint detected");
      if (deps.prettier) hints.push("Prettier detected");
      if (deps.jest || deps.vitest) hints.push("Testing detected (Jest/Vitest)");
    } catch {
      // ignore
    }
  }

  const commonDirs = ["src", "apps", "packages", "server", "client"];
  const existingDirs: string[] = [];
  for (const d of commonDirs) {
    if (await fs.pathExists(path.join(projectPath, d))) existingDirs.push(d);
  }

  let readmeHint = "";
  const readmePath = path.join(projectPath, "README.md");
  if (await fs.pathExists(readmePath)) {
    const txt = await fs.readFile(readmePath, "utf8");
    const firstLines = txt
      .split("\n")
      .slice(0, 12)
      .map((l) => l.trim())
      .filter(Boolean)
      .slice(0, 6);
    if (firstLines.length) {
      readmeHint = firstLines.map((l) => `> ${l}`).join("\n");
    }
  }

  return `# Project Context

## What is this project
(Describe the repo goal in 2-4 lines.)

${readmeHint ? `## README extract (reference)\n${readmeHint}\n` : ""}

## Detected stack
${stack.length ? stack.map((s) => `- ${s}`).join("\n") : "- Not detected (complete this)"}

## Available scripts
${scripts.length ? scripts.map((s) => `- ${s}`).join("\n") : "- No scripts (or no package.json)"}

## Structure (common folders found)
${existingDirs.length ? existingDirs.map((d) => `- ${d}/`).join("\n") : "- Not detected"}

## Hints
${hints.length ? hints.map((h) => `- ${h}`).join("\n") : "- (no hints)"}

## Work commands (complete)
- Install dependencies:
- Run dev:
- Run tests:
- Lint/format:
- Build:
`;
}

/* ======================================================
   DOCTOR HELPERS
====================================================== */

type RepoInspection = {
  hasAiDir: boolean;
  hasContext: boolean;
  hasRules: boolean;
  hasPlaybooksDir: boolean;
  playbooksCount: number;
  hasCursorRules: boolean;
  hasClaudeMd: boolean;
};

async function inspectRepo(projectPath: string): Promise<RepoInspection> {
  const aiDir = path.join(projectPath, ".ai");
  const playbooksDir = path.join(aiDir, "playbooks");

  const hasAiDir = await fs.pathExists(aiDir);
  const hasContext = await fs.pathExists(path.join(aiDir, "context.md"));
  const hasRules = await fs.pathExists(path.join(aiDir, "rules.md"));
  const hasPlaybooksDir = await fs.pathExists(playbooksDir);

  let playbooksCount = 0;
  if (hasPlaybooksDir) {
    const files = await fs.readdir(playbooksDir);
    playbooksCount = files.filter((f) => f.endsWith(".md")).length;
  }

  const hasCursorRules = await fs.pathExists(path.join(projectPath, ".cursorrules"));
  const hasClaudeMd = await fs.pathExists(path.join(projectPath, "CLAUDE.md"));

  return {
    hasAiDir,
    hasContext,
    hasRules,
    hasPlaybooksDir,
    playbooksCount,
    hasCursorRules,
    hasClaudeMd,
  };
}

type ToolDetection = Record<string, boolean>;

async function detectTools(): Promise<ToolDetection> {
  const candidates: Record<string, string[]> = {
    cursorCli: ["cursor", "cursor-agent"],
    claudeCli: ["claude", "claude-code"],
    vscode: ["code"],
    aider: ["aider"],
    opencode: ["opencode"],
    copilot: ["copilot"],
  };

  const result: ToolDetection = {};
  for (const [tool, cmds] of Object.entries(candidates)) {
    let found = false;
    for (const cmd of cmds) {
      if (await commandExists(cmd)) {
        found = true;
        break;
      }
    }
    result[tool] = found;
  }
  return result;
}

async function commandExists(cmd: string): Promise<boolean> {
  try {
    const checker = process.platform === "win32" ? "where" : "which";
    await execa(checker, [cmd]);
    return true;
  } catch {
    return false;
  }
}

function printDoctorReport(repo: RepoInspection, tools: ToolDetection) {
  console.log("\nüìÅ Repo setup:");
  console.log(`  .ai/ exists: ${repo.hasAiDir ? "‚úÖ" : "‚ùå"}`);
  console.log(`  context.md: ${repo.hasContext ? "‚úÖ" : "‚ùå"}`);
  console.log(`  rules.md: ${repo.hasRules ? "‚úÖ" : "‚ùå"}`);
  console.log(
    `  playbooks/: ${repo.hasPlaybooksDir ? "‚úÖ" : "‚ùå"} (${repo.playbooksCount} .md)`
  );

  console.log("\nüß© Adapters:");
  console.log(`  .cursorrules: ${repo.hasCursorRules ? "‚úÖ" : "‚ùå"}`);
  console.log(`  CLAUDE.md: ${repo.hasClaudeMd ? "‚úÖ" : "‚ùå"}`);

  console.log("\nüîé Tools in PATH (optional):");
  for (const [k, v] of Object.entries(tools)) {
    console.log(`  ${k}: ${v ? "‚úÖ" : "‚ùå"}`);
  }
}